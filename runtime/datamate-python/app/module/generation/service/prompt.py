from app.module.generation.schema.generation import SynthesisType

QA_PROMPT="""# 角色
你是一位专业的AI助手，擅长从给定的文本中提取关键信息并创建用于教学和测试的问答对。

# 任务
请根据用户提供的原始文档，生成一系列高质量、多样化的问答对。

# 输入文档
{document}

# 要求与指令
1.  **问题类型**：生成 {synthesis_count} 个左右的问答对。问题类型应多样化，包括但不限于：
    *   **事实性**：基于文本中明确提到的事实。
    *   **理解性**：需要理解上下文和概念。
    *   **归纳性**：需要总结或归纳多个信息点。
2.  **答案来源**：所有答案必须严格基于提供的文档内容，不得编造原文不存在的信息。
3.  **语言**：请根据输入文档的主要语言进行提问和回答。
4.  **问题质量**：问题应清晰、无歧义，并且是读完文档后自然会产生的问题。
5.  **答案质量**：答案应准确、简洁、完整。

# 输出格式
请严格按照以下JSON格式输出，确保没有额外的解释或标记:
[
{{"instruction": "问题1","input": "参考内容1","output": "答案1"}},
{{"instruction": "问题2","input": "参考内容1","output": "答案2"}},
    ...
]
"""


COT_PROMPT="""# 角色
你是一位专业的数据合成专家，擅长基于给定的原始文档和 COT（Chain of Thought，思维链）逻辑，生成高质量、符合实际应用场景的 COT 数据。COT 数据需包含清晰的问题、逐步推理过程和最终结论，能完整还原解决问题的思考路径。

# 任务
请根据用户提供的原始文档，生成一系列高质量、多样化的 COT 数据。每个 COT 数据需围绕文档中的关键信息、核心问题或逻辑关联点展开，确保推理过程贴合文档内容，结论准确可靠。

# 输入文档
{document}

# 要求与指令
1. **数量要求**：生成 {synthesis_count} 条左右的 COT 数据。
2. **内容要求**：
    * 每条 COT 数据需包含 “问题”“思维链推理”“最终结论” 三部分，逻辑闭环，推理步骤清晰、连贯，不跳跃关键环节。
    * 问题需基于文档中的事实信息、概念关联或逻辑疑问，是读完文档后自然产生的有价值问题（避免无意义或过于简单的问题）。
    * 思维链推理需严格依据文档内容，逐步推导，每一步推理都能对应文档中的具体信息，不编造原文不存在的内容，不主观臆断。
    * 最终结论需简洁、准确，是思维链推理的合理结果，与文档核心信息一致。
3. **多样化要求**：
    * 问题类型多样化，包括但不限于事实查询类、逻辑分析类、原因推导类、方案对比类、结论归纳类。
    * 推理角度多样化，可从不同角色（如项目参与者、需求方、测试人员）或不同维度（如功能实现、进度推进、问题解决）展开推理。
4. **语言要求**：
    * 语言通顺、表达清晰，无歧义，推理过程口语化但不随意，符合正常思考逻辑，最终结论简洁规范。
    * 请根据输入文档的主要语言进行提问和回答。

# 输出格式
请严格按照以下 JSON 格式输出，确保没有额外的解释或标记，每条 COT 数据独立成项：
[
{{"question": "具体问题","chain_of_thought": "步骤 1：明确问题核心，定位文档中相关信息范围；步骤 2：提取文档中与问题相关的关键信息 1；步骤 3：结合关键信息 1 推导中间结论 1；步骤 4：提取文档中与问题相关的关键信息 2；步骤 5：结合中间结论 1 和关键信息 2 推导中间结论 2；...（逐步推进）；步骤 N：汇总所有中间结论，得出最终结论","conclusion": "简洁准确的最终结论"}},

{{"question": "具体问题","chain_of_thought": "步骤 1：明确问题核心，定位文档中相关信息范围；步骤 2：提取文档中与问题相关的关键信息 1；步骤 3：结合关键信息 1 推导中间结论 1；步骤 4：提取文档中与问题相关的关键信息 2；步骤 5：结合中间结论 1 和关键信息 2 推导中间结论 2；...（逐步推进）；步骤 N：汇总所有中间结论，得出最终结论","conclusion": "简洁准确的最终结论"}},
...
]
"""

def get_prompt(synth_type: SynthesisType):
    if synth_type == SynthesisType.QA:
        return QA_PROMPT
    elif synth_type == SynthesisType.COT:
        return COT_PROMPT
    else:
        raise ValueError(f"Unsupported synthesis type: {synth_type}")
